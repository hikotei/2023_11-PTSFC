start_date  <- "2015-01-01"
# fcast_date  <- "2022-10-10"
fcast_date  <- Sys.Date()
# = = = = = = = = = = = = = = = = = = = = = = = = = =
# Load necessary packages
library(rugarch)
start_date  <- "2015-01-01"
# fcast_date  <- "2022-10-10"
fcast_date  <- Sys.Date()
DAX_prices = get.hist.quote(instrument="^GDAXI",
start=start_date, end=fcast_date,
quote="Adjusted",
provider="yahoo",
compression="d",
retclass="zoo")
library(tseries)
start_date  <- "2015-01-01"
# fcast_date  <- "2022-10-10"
fcast_date  <- Sys.Date()
DAX_prices = get.hist.quote(instrument="^GDAXI",
start=start_date, end=fcast_date,
quote="Adjusted",
provider="yahoo",
compression="d",
retclass="zoo")
DAX_prices <- fortify.zoo(DAX_prices)
names(DAX_prices) <- c("date", "price")
library(zoo)
?fortify.zoo
start_date  <- "2015-01-01"
# fcast_date  <- "2022-10-10"
fcast_date  <- Sys.Date()
DAX_prices = get.hist.quote(instrument="^GDAXI",
start=start_date, end=fcast_date,
quote="Adjusted",
provider="yahoo",
compression="d",
retclass="zoo")
DAX_prices <- fortify.zoo(DAX_prices)
names(DAX_prices) <- c("date", "price")
?get.hist.quote
source("dax_procs.R")
start_date  <- "2015-01-01"
# fcast_date  <- "2022-10-10"
fcast_date  <- Sys.Date()
DAX_prices = get.hist.quote(instrument="^GDAXI",
start=start_date, end=fcast_date,
quote="Adjusted",
provider="yahoo",
compression="d",
retclass="zoo")
# convert zoo to dataframe
DAX_prices <- fortify.zoo(DAX_prices)
names(DAX_prices) <- c("date", "price")
DAX_returns <- DAX_prices %>%
mutate(ret1_sqrd = compute_return(price, h = 1)^2,
ret1_sqrd_lag1 = lag(ret1_sqrd, 1),
ret1 = compute_return(price, h = 1),
ret1_abs_lag1 = abs(lag(ret1, 1)),
ret2 = compute_return(price, h = 2),
ret2_abs_lag1 = abs(lag(ret2, 1)),
ret3 = compute_return(price, h = 3),
ret4 = compute_return(price, h = 4),
ret5 = compute_return(price, h = 5))
start_date  <- "2015-01-01"
# fcast_date  <- "2022-10-10"
fcast_date  <- Sys.Date()
DAX_prices = get.hist.quote(instrument="^GDAXI",
start=start_date, end=fcast_date,
quote="Adjusted",
provider="yahoo",
compression="d",
retclass="zoo")
# convert zoo to dataframe
DAX_prices <- fortify.zoo(DAX_prices)
names(DAX_prices) <- c("date", "price")
DAX_returns <- DAX_prices %>%
mutate(ret1_sqrd = compute_return(price, h = 1)^2,
ret1_sqrd_lag1 = lag(ret1_sqrd, 1),
ret1 = compute_return(price, h = 1),
ret1_abs_lag1 = abs(lag(ret1, 1)),
ret2 = compute_return(price, h = 2),
ret2_abs_lag1 = abs(lag(ret2, 1)),
ret3 = compute_return(price, h = 3),
ret4 = compute_return(price, h = 4),
ret5 = compute_return(price, h = 5))
library(dplyr)
DAX_returns <- DAX_prices %>%
mutate(ret1_sqrd = compute_return(price, h = 1)^2,
ret1_sqrd_lag1 = lag(ret1_sqrd, 1),
ret1 = compute_return(price, h = 1),
ret1_abs_lag1 = abs(lag(ret1, 1)),
ret2 = compute_return(price, h = 2),
ret2_abs_lag1 = abs(lag(ret2, 1)),
ret3 = compute_return(price, h = 3),
ret4 = compute_return(price, h = 4),
ret5 = compute_return(price, h = 5))
plot(DAX_returns$price, type='l')
plot(DAX_returns$ret1, type='l')
plot(DAX_returns$price, type='l')
plot(DAX_returns$date, DAX_returns$price, type='l')
plot(DAX_returns$date, DAX_returns$ret1, type='l')
plot(DAX_returns$date, DAX_returns$price, type='l')
plot(DAX_returns$date, DAX_returns$ret1, type='l')
plot(DAX_returns$date, DAX_returns$ret2, type='l')
plot(DAX_returns$date, DAX_returns$ret1, type='l')
# Function to get rugarch model with specified parameters
get_rugarch_model <- function(p, q, arch_p, arch_q, dist) {
variance_model <- list(model = "sGARCH", garchOrder = c(arch_p, arch_q))
mean_model <- list(armaOrder = c(p, q), include.mean = TRUE)
if (dist == 'std') {
fix_df <- 3
params <- list(shape = fix_df)
model <- ugarchspec(variance.model = variance_model, mean.model = mean_model,
distribution.model = dist, fixed.pars = params)
} else if (dist == 'norm') {
model <- ugarchspec(variance.model = variance_model, mean.model = mean_model,
distribution.model = dist)
}
return(model)
}
hist <- DAX_prices %>%
mutate(ret1_sqrd = compute_return(price, h = 1)^2,
ret1_sqrd_lag1 = lag(ret1_sqrd, 1),
ret1 = compute_return(price, h = 1),
ret1_abs_lag1 = abs(lag(ret1, 1)),
ret2 = compute_return(price, h = 2),
ret2_abs_lag1 = abs(lag(ret2, 1)),
ret3 = compute_return(price, h = 3),
ret4 = compute_return(price, h = 4),
ret5 = compute_return(price, h = 5))
# = = = = = = = = = = = = = = = = = = = = = = = = = =
# Load necessary packages
library(rugarch)
library(tseries)
library(zoo)
library(dplyr)
source("dax_procs.R")
# = = = = = = = = = = = = = = = = = = = = = = = = = =
# get dax data ####
start_date  <- "2015-01-01"
# fcast_date  <- "2022-10-10"
fcast_date  <- Sys.Date()
DAX_prices = get.hist.quote(instrument="^GDAXI",
start=start_date, end=fcast_date,
quote="Adjusted",
provider="yahoo",
compression="d",
retclass="zoo")
# convert zoo to dataframe
DAX_prices <- fortify.zoo(DAX_prices)
names(DAX_prices) <- c("date", "price")
# = = = = = = = = = = = = = = = = = = = = = = = = = =
# data processing ####
# compute cumulative log returns
DAX_returns <- DAX_prices %>%
mutate(ret1_sqrd = compute_return(price, h = 1)^2,
ret1_sqrd_lag1 = lag(ret1_sqrd, 1),
ret1 = compute_return(price, h = 1),
ret1_abs_lag1 = abs(lag(ret1, 1)),
ret2 = compute_return(price, h = 2),
ret2_abs_lag1 = abs(lag(ret2, 1)),
ret3 = compute_return(price, h = 3),
ret4 = compute_return(price, h = 4),
ret5 = compute_return(price, h = 5))
plot(DAX_returns$date, DAX_returns$price, type='l')
plot(DAX_returns$date, DAX_returns$ret1, type='l')
# Function to get rugarch model with specified parameters
get_rugarch_model <- function(p, q, arch_p, arch_q, dist) {
variance_model <- list(model = "sGARCH", garchOrder = c(arch_p, arch_q))
mean_model <- list(armaOrder = c(p, q), include.mean = TRUE)
if (dist == 'std') {
fix_df <- 3
params <- list(shape = fix_df)
model <- ugarchspec(variance.model = variance_model, mean.model = mean_model,
distribution.model = dist, fixed.pars = params)
} else if (dist == 'norm') {
model <- ugarchspec(variance.model = variance_model, mean.model = mean_model,
distribution.model = dist)
}
return(model)
}
# Function to perform GARCH forecasting
r_garch_forecast <- function(y, p, q, arch_p, arch_q, dist = 'std') {
model <- get_rugarch_model(p, q, arch_p, arch_q, dist)
modelfit <- ugarchfit(spec = model, data = y, solver.control = list(tol = 1e-3))
fore <- ugarchforecast(modelfit)
mu_hist <- fitted(modelfit)[, 1]
sigma_hist <- sigma(modelfit)[, 1]
mu <- fitted(fore)[, 1]
sigma <- sigma(fore)[, 1]
return(list(mu_hist = mu_hist, sigma_hist = sigma_hist, mu = mu, sigma = sigma))
}
# Parameters
p <- 5
q <- 3
arch_p <- 2
arch_q <- 3
ignore_first <- 2000
# Example usage
lr1_res <- r_garch_forecast(DAX_returns$ret1[(ignore_first + 1):length(DAX_returns$ret1)], p, q, arch_p, arch_q)
lr2_res <- r_garch_forecast(DAX_returns$ret2[(ignore_first + 1):length(DAX_returns$ret2)], p, q, arch_p, arch_q)
lr3_res <- r_garch_forecast(DAX_returns$ret3[(ignore_first + 1):length(DAX_returns$ret3)], p, q, arch_p, arch_q)
lr4_res <- r_garch_forecast(DAX_returns$ret4[(ignore_first + 1):length(DAX_returns$ret4)], p, q, arch_p, arch_q)
lr5_res <- r_garch_forecast(DAX_returns$ret5[(ignore_first + 1):length(DAX_returns$ret5)], p, q, arch_p, arch_q)
# Extract mean and sigma values
mean_vals <- c(lr1_res$mu, lr2_res$mu, lr3_res$mu, lr4_res$mu, lr5_res$mu)
sigma_vals <- c(lr1_res$sigma, lr2_res$sigma, lr3_res$sigma, lr4_res$sigma, lr5_res$sigma)
# Function to get quantiles from distribution
get_q_from_dist <- function(mean, std, q = c(0.025, 0.25, 0.5, 0.75, 0.975)) {
quantiles <- numeric(length(q))
eps <- 1e-5
for (i in seq_along(mean)) {
quants <- qt(q, df = 3, location = mean[i], scale = std[i] + eps)
quantiles <- cbind(quantiles, quants)
}
return(quantiles[, -1])
}
# Get quantiles
quantiles_val <- get_q_from_dist(mean_vals, sigma_vals)
mean_vals
sigma_vals
# = = = = = = = = = = = = = = = = = = = = = = = = = =
# Load necessary packages
library(rugarch)
library(tseries)
library(zoo)
library(dplyr)
source("dax_procs.R")
# = = = = = = = = = = = = = = = = = = = = = = = = = =
# get dax data ####
start_date  <- "2015-01-01"
# fcast_date  <- "2022-10-10"
fcast_date  <- Sys.Date()
DAX_prices = get.hist.quote(instrument="^GDAXI",
start=start_date, end=fcast_date,
quote="Adjusted",
provider="yahoo",
compression="d",
retclass="zoo")
# convert zoo to dataframe
DAX_prices <- fortify.zoo(DAX_prices)
names(DAX_prices) <- c("date", "price")
# = = = = = = = = = = = = = = = = = = = = = = = = = =
# data processing ####
# compute cumulative log returns
DAX_returns <- DAX_prices %>%
mutate(ret1_sqrd = compute_return(price, h = 1)^2,
ret1_sqrd_lag1 = lag(ret1_sqrd, 1),
ret1 = compute_return(price, h = 1),
ret1_abs_lag1 = abs(lag(ret1, 1)),
ret2 = compute_return(price, h = 2),
ret2_abs_lag1 = abs(lag(ret2, 1)),
ret3 = compute_return(price, h = 3),
ret4 = compute_return(price, h = 4),
ret5 = compute_return(price, h = 5))
plot(DAX_returns$date, DAX_returns$price, type='l')
plot(DAX_returns$date, DAX_returns$ret1, type='l')
# = = = = = = = = = = = = = = = = = = = = = = = = = =
# rugarch ####
# Function to get rugarch model with specified parameters
get_rugarch_model <- function(p, q, arch_p, arch_q, dist) {
variance_model <- list(model = "sGARCH", garchOrder = c(arch_p, arch_q))
mean_model <- list(armaOrder = c(p, q), include.mean = TRUE)
if (dist == 'std') {
fix_df <- 3
params <- list(shape = fix_df)
model <- ugarchspec(variance.model = variance_model, mean.model = mean_model,
distribution.model = dist, fixed.pars = params)
} else if (dist == 'norm') {
model <- ugarchspec(variance.model = variance_model, mean.model = mean_model,
distribution.model = dist)
}
return(model)
}
# Function to perform GARCH forecasting
r_garch_forecast <- function(y, p, q, arch_p, arch_q, dist = 'std') {
model <- get_rugarch_model(p, q, arch_p, arch_q, dist)
modelfit <- ugarchfit(spec = model, data = y, solver.control = list(tol = 1e-3))
fore <- ugarchforecast(modelfit)
mu_hist <- fitted(modelfit)[, 1]
sigma_hist <- sigma(modelfit)[, 1]
mu <- fitted(fore)[, 1]
sigma <- sigma(fore)[, 1]
return(list(mu_hist = mu_hist, sigma_hist = sigma_hist, mu = mu, sigma = sigma))
}
# = = = = = = = = = = = = = = = = = = = = = = = = = =
# model fit & fcast ####
# Parameters
p <- 5
q <- 3
arch_p <- 2
arch_q <- 3
ignore_first <- 1000
# Example usage
lr1_res <- r_garch_forecast(DAX_returns$ret1[(ignore_first + 1):length(DAX_returns$ret1)], p, q, arch_p, arch_q)
lr2_res <- r_garch_forecast(DAX_returns$ret2[(ignore_first + 1):length(DAX_returns$ret2)], p, q, arch_p, arch_q)
lr3_res <- r_garch_forecast(DAX_returns$ret3[(ignore_first + 1):length(DAX_returns$ret3)], p, q, arch_p, arch_q)
lr4_res <- r_garch_forecast(DAX_returns$ret4[(ignore_first + 1):length(DAX_returns$ret4)], p, q, arch_p, arch_q)
lr5_res <- r_garch_forecast(DAX_returns$ret5[(ignore_first + 1):length(DAX_returns$ret5)], p, q, arch_p, arch_q)
# Extract mean and sigma values
mean_vals <- c(lr1_res$mu, lr2_res$mu, lr3_res$mu, lr4_res$mu, lr5_res$mu)
sigma_vals <- c(lr1_res$sigma, lr2_res$sigma, lr3_res$sigma, lr4_res$sigma, lr5_res$sigma)
# Function to get quantiles from distribution
get_q_from_dist <- function(mean, std, q = c(0.025, 0.25, 0.5, 0.75, 0.975)) {
quantiles <- numeric(length(q))
eps <- 1e-5
for (i in seq_along(mean)) {
quants <- qt(q, df = 3, location = mean[i], scale = std[i] + eps)
quantiles <- cbind(quantiles, quants)
}
return(quantiles[, -1])
}
# Get quantiles
quantiles_val <- get_q_from_dist(mean_vals, sigma_vals)
lr1_res
?r_garch_forecast
?ugarchforecast
View(DAX_returns)
?qt
quants <- qt(q, df = 3) * (std[i] + eps) + mean[i]
# = = = = = = = = = = = = = = = = = = = = = = = = = =
# Load necessary packages
library(rugarch)
library(tseries)
library(zoo)
library(dplyr)
source("dax_procs.R")
# = = = = = = = = = = = = = = = = = = = = = = = = = =
# get dax data ####
start_date  <- "2015-01-01"
# fcast_date  <- "2022-10-10"
fcast_date  <- Sys.Date()
DAX_prices = get.hist.quote(instrument="^GDAXI",
start=start_date, end=fcast_date,
quote="Adjusted",
provider="yahoo",
compression="d",
retclass="zoo")
# convert zoo to dataframe
DAX_prices <- fortify.zoo(DAX_prices)
names(DAX_prices) <- c("date", "price")
# = = = = = = = = = = = = = = = = = = = = = = = = = =
# data processing ####
# compute cumulative log returns
DAX_returns <- DAX_prices %>%
mutate(ret1_sqrd = compute_return(price, h = 1)^2,
ret1_sqrd_lag1 = lag(ret1_sqrd, 1),
ret1 = compute_return(price, h = 1),
ret1_abs_lag1 = abs(lag(ret1, 1)),
ret2 = compute_return(price, h = 2),
ret2_abs_lag1 = abs(lag(ret2, 1)),
ret3 = compute_return(price, h = 3),
ret4 = compute_return(price, h = 4),
ret5 = compute_return(price, h = 5))
plot(DAX_returns$date, DAX_returns$price, type='l')
plot(DAX_returns$date, DAX_returns$ret1, type='l')
# = = = = = = = = = = = = = = = = = = = = = = = = = =
# rugarch ####
# Function to get rugarch model with specified parameters
get_rugarch_model <- function(p, q, arch_p, arch_q, dist) {
variance_model <- list(model = "sGARCH", garchOrder = c(arch_p, arch_q))
mean_model <- list(armaOrder = c(p, q), include.mean = TRUE)
if (dist == 'std') {
fix_df <- 3
params <- list(shape = fix_df)
model <- ugarchspec(variance.model = variance_model, mean.model = mean_model,
distribution.model = dist, fixed.pars = params)
} else if (dist == 'norm') {
model <- ugarchspec(variance.model = variance_model, mean.model = mean_model,
distribution.model = dist)
}
return(model)
}
# Function to perform GARCH forecasting
r_garch_forecast <- function(y, p, q, arch_p, arch_q, dist = 'std') {
model <- get_rugarch_model(p, q, arch_p, arch_q, dist)
modelfit <- ugarchfit(spec = model, data = y, solver.control = list(tol = 1e-3))
fore <- ugarchforecast(modelfit)
mu_hist <- fitted(modelfit)[, 1]
sigma_hist <- sigma(modelfit)[, 1]
mu <- fitted(fore)[, 1]
sigma <- sigma(fore)[, 1]
return(list(mu_hist = mu_hist, sigma_hist = sigma_hist, mu = mu, sigma = sigma))
}
# = = = = = = = = = = = = = = = = = = = = = = = = = =
# model fit & fcast ####
# Parameters
p <- 5
q <- 3
arch_p <- 2
arch_q <- 3
ignore_first <- 1000
# Example usage
lr1_res <- r_garch_forecast(DAX_returns$ret1[(ignore_first + 1):length(DAX_returns$ret1)], p, q, arch_p, arch_q)
lr2_res <- r_garch_forecast(DAX_returns$ret2[(ignore_first + 1):length(DAX_returns$ret2)], p, q, arch_p, arch_q)
lr3_res <- r_garch_forecast(DAX_returns$ret3[(ignore_first + 1):length(DAX_returns$ret3)], p, q, arch_p, arch_q)
lr4_res <- r_garch_forecast(DAX_returns$ret4[(ignore_first + 1):length(DAX_returns$ret4)], p, q, arch_p, arch_q)
lr5_res <- r_garch_forecast(DAX_returns$ret5[(ignore_first + 1):length(DAX_returns$ret5)], p, q, arch_p, arch_q)
# Extract mean and sigma values
mean_vals <- c(lr1_res$mu, lr2_res$mu, lr3_res$mu, lr4_res$mu, lr5_res$mu)
sigma_vals <- c(lr1_res$sigma, lr2_res$sigma, lr3_res$sigma, lr4_res$sigma, lr5_res$sigma)
# Function to get quantiles from distribution
get_q_from_dist <- function(mean, std, q = c(0.025, 0.25, 0.5, 0.75, 0.975)) {
quantiles <- numeric(length(q))
eps <- 1e-5
for (i in seq_along(mean)) {
quants <- qt(q, df = 3) * (std[i] + eps) + mean[i]
quantiles <- cbind(quantiles, quants)
}
return(quantiles[, -1])
}
# Get quantiles
quantiles_val <- get_q_from_dist(mean_vals, sigma_vals)
quantiles_val
View(quantiles_val)
